<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PDF Page Picker & Merger — Crisp Online</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg0:#0ea5e9; --bg1:#22c55e; --bg:#f6f8fb;
    --card:#ffffff; --text:#0f172a; --muted:#51617e; --line:#e2e8f0;
    --brand:#2563eb; --danger:#ef4444; --ok:#16a34a;
    --chip:#f8fafc;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:
      radial-gradient(1200px 500px at 10% -10%, #e0f2fe 0%, transparent 60%),
      radial-gradient(1200px 600px at 110% -10%, #dcfce7 0%, transparent 60%),
      var(--bg);
  }
  .wrap{max-width:1280px;margin:28px auto;padding:0 16px}
  header{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-bottom:16px}
  .title{font-weight:700; letter-spacing:.2px}
  .bar{display:flex;gap:8px;flex-wrap:wrap}
  button{
    border:1px solid var(--line); background:#fff; color:var(--text);
    padding:9px 14px; border-radius:10px; cursor:pointer; font-weight:600;
    box-shadow:0 1px 2px rgba(0,0,0,.05);
  }
  button.primary{background:var(--brand);color:#fff;border-color:var(--brand)}
  button.ghost{background:transparent}
  button:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  h2{margin-top:22px;margin-bottom:8px;font-size:16px}

  .grid{
    background:var(--card); border:1px solid var(--line); border-radius:14px;
    padding:14px; display:grid; gap:12px;
    grid-template-columns:repeat(auto-fill, minmax(180px,1fr));
    box-shadow:0 6px 16px rgba(2,8,20,.06);
  }
  .item{
    position:relative; border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#fff;
    display:flex; flex-direction:column; align-items:center; padding:10px; gap:8px;
    transition:transform .12s ease, box-shadow .12s ease;
    box-shadow:0 2px 8px rgba(2,8,20,.06);
  }
  .item:hover{transform:translateY(-2px); box-shadow:0 6px 16px rgba(2,8,20,.08)}
  .thumb{
    background:#fff; border-radius:8px; display:grid; place-items:center; overflow:hidden;
    border:1px solid var(--line); padding:4px;
  }
  /* We size canvases precisely in JS; don't blur with CSS scaling */
  .thumb canvas{display:block; width:auto; height:auto}
  .meta{font-size:12px;color:var(--muted)}
  .toggle{display:flex; gap:6px;flex-wrap:wrap;justify-content:center}
  .chip{
    font-size:11px; padding:5px 8px; border-radius:999px; border:1px solid var(--line); background:var(--chip);
    cursor:pointer; user-select:none;
  }
  .removed{outline:2px dashed var(--danger);}
  .removed::after{
    content:"Removed"; position:absolute; bottom:0; left:0; right:0; text-align:center; background:#fff0f0; color:#991b1b;
    font-size:12px; padding:4px 0; border-top:1px solid #fecaca;
  }
  .footer{display:flex; align-items:center; justify-content:space-between; margin-top:14px;}
  progress{width:260px; height:16px}
  .invis{display:none}

  /* Fullscreen zoom modal */
  #zoomModal {
    position: fixed; inset: 0;
    background: rgba(2,8,20,0.85);
    display: none; align-items: center; justify-content: center;
    z-index: 1000; flex-direction: column; padding:24px;
  }
  #zoomCanvas {
    max-width: 96vw; max-height: 86vh; background:#fff; border-radius:10px;
    box-shadow:0 18px 40px rgba(0,0,0,.45);
  }
  #closeZoom {
    margin-top: 12px; padding: 8px 14px; border-radius: 999px;
    background: var(--danger); color: white; border: none; cursor: pointer;
    box-shadow:0 6px 12px rgba(239,68,68,.4);
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">PDF Page Picker & Merger</div>
      <div class="bar">
        <button id="btnLoadMain" class="primary">Load Main PDF</button>
        <button id="btnAddToMain">Add PDF to Main</button>
        <button id="btnParallel1">Load Parallel PDF 1</button>
        <button id="btnParallel2">Load Parallel PDF 2</button>
        <button id="btnRestoreAll" class="ghost">Restore All Main Pages</button>
        <button id="btnExport" class="primary">Save Merged PDF</button>
      </div>
    </header>

    <div class="hint">Online & Hi-DPI: thumbnails are rendered natively for your screen. Zoom opens a 3× crisp view. Only Main pages are saved.</div>

    <h2>Main PDF Pages</h2>
    <div id="gridMain" class="grid"></div>

    <h2>Parallel PDF 1 Pages</h2>
    <div id="gridP1" class="grid"></div>

    <h2>Parallel PDF 2 Pages</h2>
    <div id="gridP2" class="grid"></div>

    <div class="footer">
      <div class="hint" id="status">No file loaded.</div>
      <div style="display:flex;align-items:center;gap:10px">
        <progress id="prog" max="100" value="0" class="invis"></progress>
        <span class="hint" id="progText"></span>
      </div>
    </div>
  </div>

  <!-- Zoom modal -->
  <div id="zoomModal">
    <canvas id="zoomCanvas"></canvas>
    <button id="closeZoom">Close</button>
  </div>

  <!-- Hidden file inputs -->
  <input type="file" id="fileMain" accept="application/pdf" class="invis" />
  <input type="file" id="fileAddMain" accept="application/pdf" class="invis" />
  <input type="file" id="fileP1" accept="application/pdf" class="invis" />
  <input type="file" id="fileP2" accept="application/pdf" class="invis" />

  <!-- PDF.js (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
  </script>
  <!-- pdf-lib -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <script>
  (function(){
    const { PDFDocument, degrees } = PDFLib;

    const mainSources = []; // [{bytes, pdfLibDoc}]
    const mainPages = [];   // [{id, pageIndex, sourceIdx, removed, rotation, canvas, fromParallel?}]
    const p1Source = {bytes:null, pdfLibDoc:null};
    const p2Source = {bytes:null, pdfLibDoc:null};
    const p1Pages = [], p2Pages = [];
    let nextPageId = 1;

    const gridMain = document.getElementById('gridMain');
    const gridP1 = document.getElementById('gridP1');
    const gridP2 = document.getElementById('gridP2');

    const zoomModal  = document.getElementById('zoomModal');
    const zoomCanvas = document.getElementById('zoomCanvas');
    document.getElementById('closeZoom').onclick = ()=> zoomModal.style.display='none';
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') zoomModal.style.display='none'; });

    function fileToArrayBuffer(file){
      return new Promise((res,rej)=>{
        const fr = new FileReader();
        fr.onload = ()=>res(fr.result);
        fr.onerror = rej;
        fr.readAsArrayBuffer(file);
      });
    }

    // Hi-DPI thumbnail rendering (no CSS scaling blur)
    async function renderThumbCanvas(page, targetWidth = 180){
      const dpr = window.devicePixelRatio || 1;
      const unit = page.getViewport({ scale: 1 });
      const baseScale = targetWidth / unit.width; // scale so CSS width ~= targetWidth
      const viewport = page.getViewport({ scale: baseScale * dpr });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { alpha:false });
      canvas.width  = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);

      // Set CSS size (unscaled) for crispness
      canvas.style.width  = Math.round(viewport.width  / dpr) + 'px';
      canvas.style.height = Math.round(viewport.height / dpr) + 'px';

      await page.render({ canvasContext: ctx, viewport }).promise;
      return canvas;
    }

    // Hi-DPI thumbnail: render at devicePixelRatio scale, then display at 1× CSS pixels
async function renderThumbCanvas(page, targetWidth = 180){
  const dpr = window.devicePixelRatio || 1;
  const base = page.getViewport({ scale: 1 });
  const scale = (targetWidth / base.width) * dpr;     // render bigger for crispness
  const viewport = page.getViewport({ scale });

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d', { alpha:false });
  canvas.width  = Math.ceil(viewport.width);
  canvas.height = Math.ceil(viewport.height);

  // show at 1× CSS pixels (no blur)
  canvas.style.width  = Math.round(viewport.width  / dpr) + 'px';
  canvas.style.height = Math.round(viewport.height / dpr) + 'px';

  await page.render({ canvasContext: ctx, viewport }).promise;
  return canvas;
}


    // Render an entire PDF into a grid
    async function renderPDF(bytes, targetPagesArr, targetGrid, sourceStore, isMain){
      const pdfjsDoc = await pdfjsLib.getDocument({data:bytes}).promise;

      let sourceIdx = null;
      if (isMain) {
        mainSources.push({bytes, pdfLibDoc:null});
        sourceIdx = mainSources.length - 1;
      } else {
        sourceStore.bytes = bytes;
      }

      for(let i=1;i<=pdfjsDoc.numPages;i++){
        const page = await pdfjsDoc.getPage(i);
        const canvas = await renderThumbCanvas(page, 180);

        const pageObj = {
          id: nextPageId++,
          pageIndex: i-1,
          sourceIdx: isMain ? sourceIdx : null,
          removed:false,
          rotation:0,
          canvas
        };
        targetPagesArr.push(pageObj);
        targetGrid.appendChild(makeCard(pageObj, targetPagesArr, isMain, sourceStore));
      }
    }

    function makeCard(pg, arr, isMain, sourceStore){
      const card = document.createElement('div');
      card.className = 'item';
      card.dataset.id = pg.id;

      const toggles = document.createElement('div');
      toggles.className = 'toggle';

      if(isMain){
        const chipRemove = document.createElement('div');
        chipRemove.className='chip';
        chipRemove.textContent='Remove';
        chipRemove.onclick=()=>{
          pg.removed=!pg.removed;
          chipRemove.textContent = pg.removed?'Restore':'Remove';
          card.classList.toggle('removed',pg.removed);
        };
        toggles.appendChild(chipRemove);

        const chipRotate = document.createElement('div');
        chipRotate.className='chip';
        chipRotate.textContent='Rotate';
        chipRotate.onclick=()=>{
          pg.rotation = (pg.rotation+90)%360;
          pg.canvas.style.transform=`rotate(${pg.rotation}deg)`;
        };
        toggles.appendChild(chipRotate);
      } else {
        const chipAdd = document.createElement('div');
        chipAdd.className='chip';
        chipAdd.textContent='Add to Main';
        chipAdd.onclick=()=>{
          const cloneCanvas = pg.canvas.cloneNode(true);
          const newPg = {
            id: nextPageId++,
            pageIndex: pg.pageIndex,
            sourceIdx: null,
            removed:false,
            rotation:0,
            canvas: cloneCanvas,
            fromParallel: sourceStore // p1Source or p2Source
          };
          mainPages.push(newPg);
          gridMain.appendChild(makeCard(newPg, mainPages, true));
        };
        toggles.appendChild(chipAdd);
      }

      // High-res 3× zoom (× devicePixelRatio) with pdf.js
      const chipZoom = document.createElement('div');
      chipZoom.className='chip';
      chipZoom.textContent='Zoom';
     chipZoom.onclick = async () => {
  const dpr = window.devicePixelRatio || 1;
  const zoomScale = 3 * dpr;                    // 3× zoom, Hi-DPI render
  const rotationDeg = pg.rotation || 0;

  // pick the right bytes (main/parallel) for this page
  const sourceBytes = isMain
    ? (pg.fromParallel ? pg.fromParallel.bytes : mainSources[pg.sourceIdx].bytes)
    : sourceStore.bytes;

  const pdfjsDoc = await pdfjsLib.getDocument({ data: sourceBytes }).promise;
  const page = await pdfjsDoc.getPage(pg.pageIndex + 1);

  // render rotated at high resolution (no CSS rotation -> correct sizing)
  const viewport = page.getViewport({ scale: zoomScale, rotation: rotationDeg });

  // draw at full resolution
  zoomCanvas.width  = Math.ceil(viewport.width);
  zoomCanvas.height = Math.ceil(viewport.height);
  const zctx = zoomCanvas.getContext('2d', { alpha:false });
  await page.render({ canvasContext: zctx, viewport }).promise;

  // compute a single CSS width to FIT (preserve aspect ratio)
  const cssW = viewport.width  / dpr;
  const cssH = viewport.height / dpr;
  const fitScale = Math.min((window.innerWidth * 0.96) / cssW,
                            (window.innerHeight * 0.86) / cssH);

  zoomCanvas.style.width  = (cssW * fitScale) + 'px';
  zoomCanvas.style.height = 'auto';  // keep aspect ratio perfect

  document.getElementById('zoomModal').style.display = 'flex';
};

      toggles.appendChild(chipZoom);

      const thumb = document.createElement('div');
      thumb.className='thumb';
      thumb.appendChild(pg.canvas);

      const meta = document.createElement('div');
      meta.className='meta';
      meta.textContent=`Page ${pg.pageIndex+1}`;

      card.appendChild(toggles);
      card.appendChild(thumb);
      card.appendChild(meta);
      return card;
    }

    async function exportMerged(){
      if(!mainPages.length){alert('No main pages');return;}
      const out = await PDFDocument.create();

      for (const src of mainSources) if(!src.pdfLibDoc) src.pdfLibDoc = await PDFDocument.load(src.bytes);
      if (p1Source.bytes && !p1Source.pdfLibDoc) p1Source.pdfLibDoc = await PDFDocument.load(p1Source.bytes);
      if (p2Source.bytes && !p2Source.pdfLibDoc) p2Source.pdfLibDoc = await PDFDocument.load(p2Source.bytes);

      for (const pg of mainPages){
        if (pg.removed) continue;

        let srcDoc;
        if (pg.fromParallel === p1Source) srcDoc = p1Source.pdfLibDoc;
        else if (pg.fromParallel === p2Source) srcDoc = p2Source.pdfLibDoc;
        else srcDoc = mainSources[pg.sourceIdx].pdfLibDoc;

        const [copied] = await out.copyPages(srcDoc, [pg.pageIndex]);
        if (pg.rotation) copied.setRotation(degrees(pg.rotation));
        out.addPage(copied);
      }

      const bytes = await out.save();
      const blob = new Blob([bytes],{type:'application/pdf'});
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url;a.download='merged.pdf';
      document.body.appendChild(a);a.click();a.remove();
      URL.revokeObjectURL(url);
    }

    // Buttons -> inputs
    document.getElementById('btnLoadMain').onclick   = ()=> document.getElementById('fileMain').click();
    document.getElementById('btnAddToMain').onclick  = ()=> document.getElementById('fileAddMain').click();
    document.getElementById('btnParallel1').onclick  = ()=> document.getElementById('fileP1').click();
    document.getElementById('btnParallel2').onclick  = ()=> document.getElementById('fileP2').click();
    document.getElementById('btnExport').onclick     = exportMerged;
    document.getElementById('btnRestoreAll').onclick = ()=>{
      mainPages.forEach(pg=>{ pg.removed=false; pg.rotation=0; pg.canvas.style.transform='rotate(0deg)'; });
      document.querySelectorAll('#gridMain .item').forEach(c=>{
        c.classList.remove('removed');
        c.querySelectorAll('.chip').forEach(ch=>{ if (ch.textContent==='Restore') ch.textContent='Remove'; });
      });
    };

    // File handlers
    document.getElementById('fileMain').onchange = async e=>{
      const f = e.target.files[0]; if(!f) return;
      mainPages.length=0; mainSources.length=0; gridMain.innerHTML='';
      const bytes = await fileToArrayBuffer(f);
      await renderPDF(bytes, mainPages, gridMain, null, true);
      e.target.value='';
    };
    document.getElementById('fileAddMain').onchange = async e=>{
      const f = e.target.files[0]; if(!f) return;
      const bytes = await fileToArrayBuffer(f);
      await renderPDF(bytes, mainPages, gridMain, null, true); // append as another main source
      e.target.value='';
    };
    document.getElementById('fileP1').onchange = async e=>{
      const f = e.target.files[0]; if(!f) return;
      p1Pages.length=0; gridP1.innerHTML='';
      const bytes = await fileToArrayBuffer(f);
      await renderPDF(bytes, p1Pages, gridP1, p1Source, false);
      e.target.value='';
    };
    document.getElementById('fileP2').onchange = async e=>{
      const f = e.target.files[0]; if(!f) return;
      p2Pages.length=0; gridP2.innerHTML='';
      const bytes = await fileToArrayBuffer(f);
      await renderPDF(bytes, p2Pages, gridP2, p2Source, false);
      e.target.value='';
    };
  })();
  </script>
</body>
</html>
